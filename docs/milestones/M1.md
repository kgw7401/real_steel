# Milestone 1: Robot Model & Simulation

**Status:** Complete (visual verification passed)
**Ref:** `docs/PROJECT.md` Section 7, Milestone 1

## Objective

Build the URDF robot model and a PyBullet simulation interface so the robot can be loaded, visualized, and controlled programmatically. After M1, any code can import `SimulatedRobot`, call `connect()`, and command all 6 joints.

## Dependencies

- M0 complete (venv, dependencies installed, directory scaffold)
- PyBullet verified working (`tests/test_pybullet.py` passes)

## Out of Scope

- Camera or pose estimation (M2)
- Motion mapping from human to robot (M2)
- ESP32 serial communication (M3)
- Custom 3D meshes — use primitive geometries (boxes, cylinders, spheres) for MVP

---

## Deliverables

| # | Artifact | Path | Description |
|---|----------|------|-------------|
| D1 | URDF robot model | `urdf/real_steel.urdf` | 6-DOF dual-arm robot with visual, collision, and inertial properties |
| D2 | Robot interface ABC | `src/robot_interface.py` | Abstract base class defining the robot control contract |
| D3 | Simulated robot | `src/simulated_robot.py` | PyBullet implementation of `RobotInterface` |
| D4 | Simulation test | `tests/test_simulation.py` | Joint control test with GUI + headless pytest functions |

---

## Technical Spec

### S1: URDF Model — `urdf/real_steel.urdf`

The robot has a fixed torso (`base_link`) with two 3-DOF arms attached symmetrically. Each arm has shoulder pan, shoulder tilt, and elbow joints. Hands are fixed to forearms (no wrist DOF).

#### Link Tree

```
base_link (fixed to world)
├── l_shoulder_pan_link
│   └── l_shoulder_tilt_link (upper arm geometry)
│       └── l_forearm_link
│           └── l_hand_link (fixed joint)
└── r_shoulder_pan_link
    └── r_shoulder_tilt_link (upper arm geometry)
        └── r_forearm_link
            └── r_hand_link (fixed joint)
```

#### Link Specifications

| Link | Geometry | Dimensions | Mass (kg) | Material |
|------|----------|------------|-----------|----------|
| `base_link` | box | 0.10 × 0.20 × 0.25 | 0.5 | grey (0.5, 0.5, 0.5) |
| `l/r_shoulder_pan_link` | sphere | radius 0.025 | 0.02 | blue (0.2, 0.4, 0.8) |
| `l/r_shoulder_tilt_link` | cylinder | radius 0.02, length 0.15 | 0.1 | blue |
| `l/r_forearm_link` | cylinder | radius 0.0175, length 0.12 | 0.08 | blue |
| `l/r_hand_link` | sphere | radius 0.025 | 0.05 | red (0.8, 0.2, 0.2) |

Visual origins for cylinders: offset along Z by `-length/2` so the geometry hangs downward from the joint.

#### Joint Specifications

| Joint | Type | Parent → Child | Origin (xyz) | Axis | Lower (rad) | Upper (rad) |
|-------|------|---------------|--------------|------|-------------|-------------|
| `l_shoulder_pan_joint` | revolute | `base_link` → `l_shoulder_pan_link` | 0.0, 0.12, 0.10 | 0 0 1 (Z) | -1.5708 | 1.5708 |
| `l_shoulder_tilt_joint` | revolute | `l_shoulder_pan_link` → `l_shoulder_tilt_link` | 0 0 0 | 0 1 0 (Y) | -0.7854 | 2.3562 |
| `l_elbow_joint` | revolute | `l_shoulder_tilt_link` → `l_forearm_link` | 0, 0, -0.15 | 0 1 0 (Y) | 0 | 2.3562 |
| `l_hand_joint` | fixed | `l_forearm_link` → `l_hand_link` | 0, 0, -0.12 | — | — | — |
| `r_shoulder_pan_joint` | revolute | `base_link` → `r_shoulder_pan_link` | 0.0, -0.12, 0.10 | 0 0 1 (Z) | -1.5708 | 1.5708 |
| `r_shoulder_tilt_joint` | revolute | `r_shoulder_pan_link` → `r_shoulder_tilt_link` | 0 0 0 | 0 1 0 (Y) | -0.7854 | 2.3562 |
| `r_elbow_joint` | revolute | `r_shoulder_tilt_link` → `r_forearm_link` | 0, 0, -0.15 | 0 1 0 (Y) | 0 | 2.3562 |
| `r_hand_joint` | fixed | `r_forearm_link` → `r_hand_link` | 0, 0, -0.12 | — | — | — |

All revolute joints: `effort="10"`, `velocity="2.0"`.

Left arm shoulder attaches at Y=+0.12 (robot's left), right at Y=-0.12.

#### Inertia

Use simplified inertia tensors. For each link, set diagonal values proportional to mass (e.g., `ixx=iyy=izz=0.001*mass` for rough bodies). Off-diagonal terms are 0. These values don't need to be physically precise for MVP — they just need to keep the simulation stable.

### S2: `src/robot_interface.py`

Abstract base class that both `SimulatedRobot` and `RealRobot` (M3) will implement.

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
import numpy as np

@dataclass
class JointState:
    positions: np.ndarray   # shape (6,), radians
    velocities: np.ndarray  # shape (6,), rad/s
    timestamp: float        # time.time()

class RobotInterface(ABC):
    NUM_JOINTS = 6
    JOINT_NAMES = [
        'l_shoulder_pan', 'l_shoulder_tilt', 'l_elbow',
        'r_shoulder_pan', 'r_shoulder_tilt', 'r_elbow',
    ]

    @abstractmethod
    def connect(self) -> bool: ...

    @abstractmethod
    def disconnect(self) -> None: ...

    @abstractmethod
    def set_joint_positions(self, positions: np.ndarray) -> None: ...

    @abstractmethod
    def get_joint_state(self) -> JointState: ...

    @abstractmethod
    def home(self) -> None: ...

    @abstractmethod
    def is_connected(self) -> bool: ...
```

### S3: `src/simulated_robot.py`

PyBullet implementation of `RobotInterface`.

**Constructor parameters:**
- `urdf_path: str` — path to URDF file
- `gui: bool = True` — GUI vs DIRECT mode
- `timestep: float = 1/240` — simulation timestep

**Internal state:**
- `client: int | None` — PyBullet physics client ID
- `robot_id: int | None` — loaded URDF body ID
- `joint_indices: list[int]` — maps our 6-joint order to PyBullet joint indices

**Key behaviors:**

| Method | Behavior |
|--------|----------|
| `connect()` | Connect to PyBullet (GUI or DIRECT), set gravity, load URDF at position [0, 0, 0.5] with `useFixedBase=True`, map joints, call `home()`, configure camera if GUI |
| `_map_joints()` | Iterate `p.getNumJoints()`, build name→index map, resolve our 6 URDF joint names to indices. Raise `ValueError` if any joint missing. |
| `disconnect()` | `p.disconnect(self.client)`, set client to None |
| `set_joint_positions(positions)` | Validate length==6. For each joint, call `p.setJointMotorControl2` with `POSITION_CONTROL`, `force=10.0`, `positionGain=0.3`, `velocityGain=1.0` |
| `get_joint_state()` | Read `p.getJointState` for each mapped index, return `JointState` |
| `home()` | `set_joint_positions(np.zeros(6))`, step simulation 100 times to settle |
| `step()` | `p.stepSimulation()` |
| `is_connected()` | Check `client is not None and p.isConnected(self.client)` |
| `add_debug_controls()` | Add 6 PyBullet GUI sliders (one per joint, range in degrees) + a reset button |
| `read_debug_controls()` | Read slider values, convert degrees→radians, return `np.ndarray` |

**Camera configuration (GUI mode):**
- `cameraDistance=1.0`, `cameraYaw=45`, `cameraPitch=-30`, `cameraTargetPosition=[0, 0, 0.5]`

### S4: `tests/test_simulation.py`

Both a standalone GUI demo and headless pytest tests.

#### Standalone mode (`python tests/test_simulation.py`)

1. Create `SimulatedRobot(urdf_path='urdf/real_steel.urdf', gui=True)`
2. `connect()`
3. Run a test sequence — move through 5 poses (each held for 1 second at 240 Hz):
   - Raise left arm: `[0.0, 0.5, 0.5, 0.0, 0.0, 0.0]`
   - Swing left: `[0.5, 0.5, 1.0, 0.0, 0.0, 0.0]`
   - Swing right: `[-0.5, 0.5, 1.0, 0.0, 0.0, 0.0]`
   - Center: `[0.0, 0.5, 0.5, 0.0, 0.0, 0.0]`
   - Home: `[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]`
4. Print current joint state after each pose
5. `disconnect()`

#### Headless pytest functions

**`test_urdf_loads()`**
- Connect in DIRECT mode
- Assert `robot.is_connected()` is True
- Assert `len(robot.joint_indices) == 6`
- Disconnect

**`test_joint_control()`**
- Connect in DIRECT mode
- Set positions `[0.5, 0.3, 1.0, -0.5, 0.3, 1.0]`
- Step simulation 200 times
- Read joint state
- Assert each position is within 0.1 rad of target
- Disconnect

**`test_joint_limits()`**
- Connect in DIRECT mode
- Set positions beyond limits (e.g., `[5.0, 5.0, 5.0, 5.0, 5.0, 5.0]`)
- Step simulation 200 times
- Read joint state
- Assert each position is within the URDF-defined joint limits
- Disconnect

**`test_home()`**
- Connect in DIRECT mode
- Set positions to non-zero values, step 200 times
- Call `home()`
- Read joint state
- Assert all positions are within 0.1 rad of 0.0
- Disconnect

---

## Tasks

### Task 1.1: Create URDF model

Write `urdf/real_steel.urdf` as specified in S1. Use the exact link tree, dimensions, joint limits, and axes from the spec.

**Produces:** `urdf/real_steel.urdf`
**Done when:** File is valid XML and matches the spec's link/joint structure

### Task 1.2: Implement `src/robot_interface.py`

Replace the stub with the full ABC as specified in S2.

**Produces:** `src/robot_interface.py`
**Done when:** `from src.robot_interface import RobotInterface, JointState` succeeds

### Task 1.3: Implement `src/simulated_robot.py`

Replace the stub with the full PyBullet implementation as specified in S3. Includes `add_debug_controls()` and `read_debug_controls()`.

**Requires:** Task 1.1, Task 1.2
**Produces:** `src/simulated_robot.py`
**Done when:** `from src.simulated_robot import SimulatedRobot` succeeds

### Task 1.4: Create `tests/test_simulation.py`

Write the test script as specified in S4 — standalone GUI demo + 4 headless pytest functions.

**Requires:** Task 1.3
**Produces:** `tests/test_simulation.py`
**Done when:** `python tests/test_simulation.py` shows robot moving through poses in GUI

### Task 1.5: Run headless pytest checks

Run `pytest tests/test_simulation.py -v` to verify all 4 headless tests pass.

**Requires:** Task 1.4
**Done when:** `pytest` exits with 0 failures

### Task 1.6: Visual verification

Run `python tests/test_simulation.py` and visually verify:
- Robot torso is upright, centered
- Arms hang at sides in home position
- Arms move correctly through the test sequence
- Joint limits prevent impossible poses

**Requires:** Task 1.5
**Done when:** Manual visual confirmation (no automated check)

---

## Acceptance Criteria

- [ ] `urdf/real_steel.urdf` loads in PyBullet without errors
- [ ] Robot appears correctly: torso upright at [0, 0, 0.5], arms at sides
- [ ] All 6 revolute joints respond to position commands
- [ ] Joint limits are respected (cannot exceed URDF limits)
- [ ] `get_joint_state()` returns positions within 0.1 rad of commanded targets after settling
- [ ] `home()` returns all joints to 0.0
- [ ] `pytest tests/test_simulation.py` passes all 4 headless tests
- [ ] `python tests/test_simulation.py` shows robot moving through the 5-pose sequence in GUI
