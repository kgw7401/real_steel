# Milestone 3: Hardware Integration

**Status:** Not Started
**Ref:** `docs/PROJECT.md` Sections 6, 7 (Milestones 3 & 4)

## Objective

Connect the Mac Python pipeline to real hardware via serial. After M3, running `python src/main.py --port /dev/tty.usbserial-XXXX` controls the physical robot's 8 servos through the full camera→pose→angles→mapper→serial chain.

This milestone covers both the ESP32 firmware and the Python `RealRobot` class. It combines the PRD's Milestones 3 and 4 because `main.py` already exists and just needs the `--port` path wired up.

## Dependencies

- M0 complete (venv, dependencies)
- M1 complete (URDF, `SimulatedRobot`)
- M2 complete (full perception pipeline, `main.py`)
- ESP32 DevKit C + USB cable
- PCA9685 PWM driver board
- 8× MG996R servos (or similar)
- 6V 5A power supply for servos

## Out of Scope

- ROS2 migration (Phase B)
- Custom 3D-printed chassis or frame
- Torque/current monitoring
- Wireless communication (Bluetooth/WiFi)
- Motion recording/playback

---

## Key Design Decision: 8 DOF

The PRD specifies 6 DOF (3 per arm: pan, tilt, elbow). The actual system has **8 DOF** (4 per arm: roll, tilt, pan, elbow). The firmware and `RealRobot` must handle 8 joints.

| Joint | Index | Servo # | Range | URDF Name |
|-------|-------|---------|-------|-----------|
| L Shoulder Roll | 0 | 0 | -20° to +135° | `l_shoulder_roll_joint` |
| L Shoulder Tilt | 1 | 1 | -90° to +90° | `l_shoulder_tilt_joint` |
| L Shoulder Pan | 2 | 2 | -90° to +90° | `l_shoulder_pan_joint` |
| L Elbow | 3 | 3 | 0° to +135° | `l_elbow_joint` |
| R Shoulder Roll | 4 | 4 | -20° to +135° | `r_shoulder_roll_joint` |
| R Shoulder Tilt | 5 | 5 | -90° to +90° | `r_shoulder_tilt_joint` |
| R Shoulder Pan | 6 | 6 | -90° to +90° | `r_shoulder_pan_joint` |
| R Elbow | 7 | 7 | 0° to +135° | `r_elbow_joint` |

The serial protocol uses 8 values instead of 6:
- `J:<a0>,<a1>,<a2>,<a3>,<a4>,<a5>,<a6>,<a7>`
- `P:<a0>,<a1>,<a2>,<a3>,<a4>,<a5>,<a6>,<a7>`

---

## Deliverables

| # | Artifact | Path | Description |
|---|----------|------|-------------|
| D1 | ESP32 firmware | `esp32/real_steel_controller/` | Arduino sketch + headers for serial→PCA9685→servo control |
| D2 | Real robot class | `src/real_robot.py` | `RobotInterface` implementation using pyserial |
| D3 | Main.py update | `src/main.py` | Wire `--port` flag to `RealRobot` |
| D4 | Serial test script | `tests/test_serial.py` | Standalone + pytest tests for ESP32 communication |
| D5 | Config update | `config/settings.yaml` | Add servo calibration section |

---

## Technical Spec

### S1: ESP32 Firmware — `esp32/real_steel_controller/`

#### File Structure

```
esp32/real_steel_controller/
├── real_steel_controller.ino    # Main sketch (setup + loop)
├── config.h                     # Pin definitions, servo limits, constants
├── servo_controller.h           # PCA9685 wrapper, angle→pulse mapping
└── serial_handler.h             # Command parsing and response formatting
```

#### `config.h`

```cpp
#pragma once

#define SERIAL_BAUD 115200
#define NUM_SERVOS 8
#define I2C_SDA 21
#define I2C_SCL 22
#define PWM_FREQ 50

// Joint order: L_roll, L_tilt, L_pan, L_elbow, R_roll, R_tilt, R_pan, R_elbow
// Servo pulse width limits (microseconds) — calibrate per servo
const int SERVO_MIN_US[NUM_SERVOS] = {500, 500, 500, 500, 500, 500, 500, 500};
const int SERVO_MAX_US[NUM_SERVOS] = {2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500};

// Angle limits (degrees) — must match URDF / motion_mapper joint limits
const float ANGLE_MIN[NUM_SERVOS] = {-20, -90, -90, 0, -20, -90, -90, 0};
const float ANGLE_MAX[NUM_SERVOS] = {135, 90, 90, 135, 135, 90, 90, 135};

// Home positions (degrees)
const float HOME_ANGLES[NUM_SERVOS] = {0, 0, 0, 0, 0, 0, 0, 0};

// Safety: disconnect timeout (ms). If no command received within this period, home and disable.
#define WATCHDOG_TIMEOUT_MS 2000
```

#### `servo_controller.h`

Wraps the Adafruit PWM Servo Driver library.

```cpp
void servo_init();                              // Wire.begin, pwm.begin, pwm.setPWMFreq
void servo_set_angle(int servo, float angle);   // Maps angle → pulse width → PCA9685 tick
void servo_home();                              // Move all to HOME_ANGLES
void servo_enable(bool enabled);                // If disabled, stop sending PWM signals
bool servo_is_enabled();
float servo_get_angle(int servo);               // Return last commanded angle
```

**`servo_set_angle` implementation:**
1. Clamp angle to `[ANGLE_MIN[servo], ANGLE_MAX[servo]]`
2. Map angle to pulse width: `pulse_us = map(angle*10, min*10, max*10, SERVO_MIN_US, SERVO_MAX_US)`
3. Convert to PCA9685 tick: `tick = (pulse_us * 4096) / 20000`
4. Call `pwm.setPWM(servo, 0, tick)`
5. Store angle in `currentAngles[servo]`

#### `serial_handler.h`

Parses incoming serial commands and sends responses.

```cpp
void serial_init();                 // Serial.begin(SERIAL_BAUD)
void serial_poll();                 // Read chars, buffer until '\n', call handle_command
void serial_send_ok();              // Serial.println("OK")
void serial_send_error(int code, const char* msg);
void serial_send_positions();       // "P:<a0>,<a1>,...,<a7>"
void serial_send_ready();           // Serial.println("READY")
```

**Command parsing (`handle_command`):**

| Command | Format | Handler |
|---------|--------|---------|
| `J` | `J:<a0>,<a1>,...,<a7>` | Parse 8 floats, validate ranges, set all servos |
| `S` | `S:<joint>:<angle>` | Parse index + angle, validate, set single servo |
| `H` | `H` | Call `servo_home()`, send OK |
| `Q` | `Q` | Call `serial_send_positions()` |
| `E` | `E:<0\|1>` | Call `servo_enable()`, send OK |

**Error codes:**
- `ERR:1:msg` — Invalid command format (wrong arg count, unparseable)
- `ERR:2:msg` — Angle out of range
- `ERR:3:msg` — Invalid joint index (for `S:` command)
- `ERR:4:msg` — Servo/hardware error

#### `real_steel_controller.ino`

```cpp
#include "config.h"
#include "servo_controller.h"
#include "serial_handler.h"

unsigned long lastCommandTime = 0;

void setup() {
    serial_init();
    servo_init();
    servo_home();
    serial_send_ready();
    lastCommandTime = millis();
}

void loop() {
    serial_poll();  // sets lastCommandTime on valid command

    // Watchdog: if no commands for WATCHDOG_TIMEOUT_MS, home and disable
    if (millis() - lastCommandTime > WATCHDOG_TIMEOUT_MS) {
        if (servo_is_enabled()) {
            servo_home();
            servo_enable(false);
        }
    }
}
```

### S2: `src/real_robot.py`

Implements `RobotInterface` using pyserial.

```python
class RealRobot(RobotInterface):
    def __init__(self, port: str, baud: int = 115200, timeout: float = 1.0)
    def connect(self) -> bool
    def disconnect(self) -> None
    def set_joint_positions(self, positions: np.ndarray) -> None
    def get_joint_state(self) -> JointState
    def home(self) -> None
    def is_connected(self) -> bool
```

**Constructor:**
- Store port, baud, timeout
- `self.serial: serial.Serial | None = None`
- `self.last_positions: np.ndarray = np.zeros(NUM_JOINTS)` for tracking

**`connect()`:**
1. Open `serial.Serial(port, baud, timeout=timeout)`
2. `time.sleep(2)` — wait for ESP32 reset after USB connect
3. Read lines until `READY` received (with timeout, max 5 seconds)
4. Send `E:0\n` (disable servos — safe startup)
5. Send `H\n` (home position)
6. Send `E:1\n` (enable servos)
7. Return `True` on success

**`disconnect()`:**
1. If connected: send `E:0\n`, send `H\n`, close serial, set to None

**`set_joint_positions(positions)`:**
1. Validate length == NUM_JOINTS (8)
2. Convert radians to degrees: `deg = np.rad2deg(positions)`
3. Format: `J:{deg[0]:.1f},{deg[1]:.1f},...,{deg[7]:.1f}\n`
4. Write to serial
5. Read response line
6. If not `OK`, print warning (don't raise — keep loop running)
7. Update `self.last_positions`

**`get_joint_state()`:**
1. Send `Q\n`
2. Read response
3. Parse `P:<a0>,...,<a7>` — split on `,`, convert to float array
4. Convert degrees to radians
5. Return `JointState(positions=..., velocities=np.zeros(8), timestamp=time.time())`

**`home()`:**
1. Send `H\n`
2. Read response (consume OK)
3. Update `self.last_positions` to zeros

**`is_connected()`:**
- Return `self.serial is not None and self.serial.is_open`

**Error handling:**
- All serial reads/writes wrapped in try/except
- `serial.SerialTimeoutException` — log warning, don't crash
- `serial.SerialException` — log error, mark disconnected
- On any serial error in `set_joint_positions`, skip silently (freeze-on-failure safety)

### S3: `src/main.py` Update

The current `main.py` only uses `SimulatedRobot`. Add the `--port` path:

```python
if args.sim:
    robot = SimulatedRobot(urdf_path=..., gui=True)
elif args.port or cfg.get("serial", {}).get("port"):
    port = args.port or cfg["serial"]["port"]
    baud = cfg.get("serial", {}).get("baud", 115200)
    robot = RealRobot(port=port, baud=baud)
else:
    print("Specify --sim or --port")
    sys.exit(1)
```

Also:
- Don't call `robot.step()` for `RealRobot` (no simulation to advance)
- Don't poll PyBullet keyboard events for `RealRobot`
- ESC key should send `E:0` before disconnecting

### S4: `tests/test_serial.py`

Both a standalone CLI tool and pytest functions.

#### Standalone mode (`python tests/test_serial.py --port /dev/tty.usbserial-XXXX`)

Interactive test sequence:
1. Connect and wait for `READY`
2. Test `H` — home, expect `OK`
3. Test `Q` — query, expect `P:0.0,0.0,...`
4. Test `J:45.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0` — single roll, expect `OK`
5. Test `Q` — verify position 0 is 45.0
6. Test `J:999,...` — out of range, expect `ERR:2:...`
7. Test `S:3:90.0` — single joint, expect `OK`
8. Test `E:0` — disable, expect `OK`
9. Test `E:1` — enable, expect `OK`
10. Home and close

Print latency for each command (round-trip time).

#### Pytest functions (headless, skipped without `--port`)

Use `pytest.mark.skipif` or a `--port` conftest fixture to skip when no hardware is present.

**`test_connect_ready(port)`**
- Open serial, assert `READY` received within 5 seconds

**`test_home_command(port)`**
- Send `H\n`, assert response is `OK`

**`test_joint_command_roundtrip(port)`**
- Send `J:...`, assert `OK`
- Send `Q`, parse response, assert angles match within 0.5°

**`test_error_handling(port)`**
- Send `J:999,...`, assert response starts with `ERR:2`
- Send `X:bad\n`, assert response starts with `ERR:1`

**`test_latency(port)`**
- Send 100 `J:` commands, measure round-trip time
- Assert average < 10ms

### S5: Config Update

Add servo calibration section to `config/settings.yaml`:

```yaml
serial:
  port: /dev/tty.usbserial-0001
  baud: 115200
  timeout: 1.0

servo_calibration:
  # Pulse width limits per servo (microseconds)
  # Adjust during physical calibration (Task 3.2)
  pulse_min: [500, 500, 500, 500, 500, 500, 500, 500]
  pulse_max: [2500, 2500, 2500, 2500, 2500, 2500, 2500, 2500]
```

The pulse width values are reference data — the actual calibration is burned into `config.h` on the ESP32. This section documents the current calibration for reproducibility.

---

## Wiring Diagram

```
ESP32 DevKit C          PCA9685              Servos (MG996R × 8)
┌─────────────┐      ┌──────────┐       ┌────────────────────────┐
│         3V3 │──────│ VCC      │       │                        │
│         GND │──────│ GND      │───────│ GND (brown)            │
│      GPIO21 │──────│ SDA      │       │                        │
│      GPIO22 │──────│ SCL      │       │                        │
│             │      │          │       │                        │
│             │      │ V+   ────┼───────│ VCC (red)              │
│             │      │ (6V ext) │       │                        │
│             │      │          │       │                        │
│             │      │ PWM 0 ───┼───────│ SIG  L_SHOULDER_ROLL   │
│             │      │ PWM 1 ───┼───────│ SIG  L_SHOULDER_TILT   │
│             │      │ PWM 2 ───┼───────│ SIG  L_SHOULDER_PAN    │
│             │      │ PWM 3 ───┼───────│ SIG  L_ELBOW           │
│             │      │ PWM 4 ───┼───────│ SIG  R_SHOULDER_ROLL   │
│             │      │ PWM 5 ───┼───────│ SIG  R_SHOULDER_TILT   │
│             │      │ PWM 6 ───┼───────│ SIG  R_SHOULDER_PAN    │
│             │      │ PWM 7 ───┼───────│ SIG  R_ELBOW           │
└─────────────┘      └──────────┘       └────────────────────────┘
                           │
                     ┌─────┴─────┐
                     │ 6V 5A PSU │
                     │ (Servos)  │
                     └───────────┘

Note: ESP32 powered via USB (separate from servo PSU).
      PCA9685 logic powered from ESP32 3V3.
      PCA9685 V+ powered from external 6V PSU (servo power only).
```

---

## Tasks

### Task 3.0: Single servo smoke test (no PCA9685)

Verify a single servo works end-to-end: ESP32 GPIO → servo, driven by the camera pipeline. Requires only an ESP32 + 1 servo + 3 jumper wires, powered through USB.

**Wiring:**
```
Servo signal (orange) -> ESP32 GPIO 13
Servo VCC (red)       -> External 5-6V PSU (+)
Servo GND (brown)     -> External PSU (-) AND ESP32 GND (common ground)
```

**WARNING:** Do NOT power the servo from the ESP32 5V/3.3V pin. MG996R servos draw up to 2.5A stall current which will fry the ESP32's voltage regulator. Always use a separate power supply for servo VCC. The only connection between ESP32 and servo power is shared GND.

**Steps:**
1. Flash `esp32/test_sketches/single_servo_test/single_servo_test.ino`
2. Open Serial Monitor at 115200 — servo sweeps on boot, prints `READY`
3. Test manually: type `A:45` to set 45°, `H` to home, `Q` to query
4. Run camera-driven test: `python tests/test_single_servo.py --port /dev/tty.usbserial-XXXX --joint 1`
5. Move your arm — servo should follow your shoulder tilt

**Produces:** `esp32/test_sketches/single_servo_test/single_servo_test.ino`, `tests/test_single_servo.py`
**Done when:** Servo visibly tracks arm movement from camera feed

### Task 3.1: ESP32 basic setup and I2C verification

Set up the Arduino project structure. Write `config.h` and `servo_controller.h`. Flash a minimal sketch that initializes the PCA9685 and sweeps one servo.

**Produces:** `esp32/real_steel_controller/config.h`, `esp32/real_steel_controller/servo_controller.h`
**Done when:** Single servo moves when sketch runs, I2C scan detects PCA9685 at 0x40

### Task 3.2: Servo pulse width calibration

For each of the 8 servos, determine the actual min/max pulse widths that correspond to the mechanical angle limits. Update `SERVO_MIN_US` and `SERVO_MAX_US` in `config.h`.

**Requires:** Task 3.1
**Produces:** Calibrated values in `config.h`, documented in `config/settings.yaml`
**Done when:** Each servo reaches its correct min and max angle within ±2°

### Task 3.3: Implement serial command handler

Write `serial_handler.h` and the main `real_steel_controller.ino`. Implement all 5 commands (`J`, `S`, `H`, `Q`, `E`) and error responses.

**Requires:** Task 3.1
**Produces:** `esp32/real_steel_controller/serial_handler.h`, `esp32/real_steel_controller/real_steel_controller.ino`
**Done when:** All commands respond correctly via Arduino Serial Monitor

### Task 3.4: Implement `src/real_robot.py`

Replace the stub with the full `RealRobot` implementation per S2.

**Requires:** Task 3.3 (firmware running on ESP32)
**Produces:** `src/real_robot.py`
**Done when:** `from src.real_robot import RealRobot` succeeds, and a standalone test connects and sends commands

### Task 3.5: Update `src/main.py` for `--port` mode

Wire the `--port` flag to create a `RealRobot` instance per S3. Handle the differences from simulation (no `step()`, no PyBullet camera, ESC sends `E:0`).

**Requires:** Task 3.4
**Produces:** Updated `src/main.py`
**Done when:** `python src/main.py --port /dev/tty.usbserial-XXXX` connects to ESP32 and sends joint commands

### Task 3.6: Create `tests/test_serial.py`

Write the test script per S4 — standalone interactive test + pytest functions.

**Requires:** Task 3.4
**Produces:** `tests/test_serial.py`
**Done when:** `python tests/test_serial.py --port ...` runs the full test sequence and reports latencies

### Task 3.7: Integration test — real hardware mirroring

Run `python src/main.py --port /dev/tty.usbserial-XXXX` and verify the physical robot mirrors arm movements from the camera feed.

**Requires:** Tasks 3.5, 3.6
**Done when:** Manual verification — robot mirrors user's punches via camera

### Task 3.8: Latency and stability test

Run the system for 10 minutes continuous. Measure:
- Serial round-trip latency (should be < 10ms average)
- Command rate (should sustain 50 Hz without drops)
- No servo jitter or brownout

**Requires:** Task 3.7
**Done when:** 10-minute run completes without errors, latency within target

---

## Safety Checklist

- [ ] Servo PSU is separate from ESP32 USB power
- [ ] `E:0` disables all servos (verified)
- [ ] Watchdog timer homes and disables servos after 2s of no commands
- [ ] ESC key in `main.py` sends `E:0` before closing serial
- [ ] Joint angle limits in `config.h` match URDF limits
- [ ] `disconnect()` always sends `E:0` then `H` before closing
- [ ] No servo commands sent before `READY` is received
- [ ] Safe startup sequence: connect → READY → E:0 → H → E:1

---

## Acceptance Criteria

- [ ] ESP32 firmware compiles and flashes without errors
- [ ] All 5 serial commands (`J`, `S`, `H`, `Q`, `E`) work correctly
- [ ] Invalid commands return appropriate `ERR` responses
- [ ] `python src/main.py --port ...` controls physical robot via camera
- [ ] Serial round-trip latency < 10ms average
- [ ] 50 Hz command rate sustained without drops
- [ ] Watchdog timer triggers after 2s disconnect (servos home and disable)
- [ ] ESC key cleanly disables servos and exits
- [ ] 10-minute continuous operation without errors or servo brownout
- [ ] `python src/main.py --sim` still works (no regression)
